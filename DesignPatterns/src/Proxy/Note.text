代理模式:
代理模式是对象的结构模式。代理模式给某一个对象提供代理对象，并由代理对象控制对源对象的引用。

所谓的代理，就是一个人或者一个机构代表另外一个人或者另外一个机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，
而代理对象可以在客户端和目标对象中间起到中介的作用。

代理模式中的角色有：
抽象对象角色(AbstractObject)：声明了目标对象和代理对象的共同接口，这样依赖在任何可以使用目标对象的地方都可以使用代理对象。

目标对象角色(RealObject)：定义了代理对象所代表的目标对象。

代理对象角色(ProxyObject)：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，
以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或者之后，执行某个操作，而不是单纯的将调用传递给目标对象。

静态代理方式总结:
可以做到在不修改目标对象的前提下，拓展目标对象的功能。
缺点是：因为代理对象需要同目标对象实现同样的接口，所以会有很多的代理类，造成类过多；并且，一旦接口中增加方法，目标对象同代理对象都需要进行维护。
解决这个缺点的方式就是使用动态代理。

动态代理 使用字节码重组技术实现
动态代理主要有如下特点：
代理对象不需要实现目标对象的接口。
代理对象的生成，使用的是Java的API，动态的在内存中构件代理对象(这需要我们指定创建代理对象/目标对象的接口的类型)。
动态代理也叫做JDK代理、接口代理。

JDK中生成代理对象的API
代理类所在的包为：java.lang.reflect.Proxy。

JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，源码中的方法定义为：
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
{
    //......
}

注意，该方法在Proxy类中是静态方法，且接收的三个参数依次为：
ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的。

Class<?>[] interfaces：目标对象实现的接口类型，使用泛型方式确认类型。

InvocationHandler h：事件处理。执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。


Cglib代理
上面的静态代理和动态代理模式都需要目标对象是一个实现了接口的目标对象，但是有的时候，目标对象可能只是一个单独的对象，并没有实现任何的接口，
这个时候，我们就可以使用目标对象子类的方式实现代理，这种代理方式就是：Cglib代理

定义
Cglib代理，也叫做子类代理，它是在内存中构件一个子类对象，从而实现对目标对象的功能拓展。

JDK的动态代理有个限制，就是使用动态代理的目标对象必须实现至少一个接口，由此，没有实现接口但是想要使用代理的目标对象，就可以使用Cglib代理。
Cglib是强大的高性能的代码生成包，它可以在运行期间拓展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和synaop，
为他们提供方法的interception(拦截)。
Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类，不鼓励直接只使用ASM，
因为它要求你必须对JVM内部结构，包括class文件的格式和指令集都很熟悉。

需要引入Cglib的jar文件，在Maven中可以直接在POM.xml中添加下列引用即可。
 <!-- https://mvnrepository.com/artifact/cglib/cglib -->
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.2.5</version>
        </dependency>

        在Spring的AOP编程中：

        如果加入容器的目标对象有实现接口，就使用JDK代理
        如果目标对象没有实现接口，就使用Cglib代理。